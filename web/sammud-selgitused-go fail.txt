/*
1. Go backendi arendamine
API-ga suhtlemine: Sinu Go server peab tegema päringuid Node.js-iga loodud Cars API-le, et tuua andmeid autode, mudelite, tootjate ja kategooriate kohta.
Vaata üle Go standardteekide
	net/http pakett, et teha HTTP päringuid.
Asünkroonse töötluse rakendamine: Go kasutab gorutiine ja kanaleid, et hõlbustada asünkroonset töötlust. Mõtle, kuidas saaksid neid konstruktsioone kasutada,
et teha API päringuid asünkroonselt või käidelda kasutajategevusi ilma serveri tööd aeglustamata.
*/

/*
2. Kasutajaliidese arendamine
Staatiline failide serveerimine: Sinu Go veebiserver peaks suutma serveerida HTML, CSS ja JavaScript faile, et luua dünaamiline ja interaktiivne kasutajaliides.
	Uuri net/http paketi võimalusi staatiliste failide serveerimiseks.
Dünaamiline sisu: HTML templiidid (html/template) aitavad sul serveris genereerida dünaamilist sisu, mis põhineb Cars API-st saadud andmetel.
See võimaldab kuvada autoandmeid, tootja infot jms.
*/

/*
3. Täpsemad funktsionaalsused
Filtreerimine ja otsing: Sinu server peaks suutma töödelda kasutaja päringuid ja pakkuda filtreerimise võimalusi.
	See võib nõuda lisaloogikat API päringutes või andmete töötlemisel serveris.
Mudelite võrdlus: Võimalda kasutajatel valida mitu autot ja kuvada nende spetsifikatsioonid kõrvuti.
	See nõuab dünaamilist UI loogikat ja võimalust salvestada kasutaja valikuid.
*/

/*
4. Testimine ja veatöötlus
Testimine: Kirjuta testid oma Go koodile, kasutades Go testimisraamistikku (testing pakett). See hõlmab nii ühikteste kui ka integratsiooniteste.
Veatöötlus: Veendu, et su server suudab korrektselt käidelda erinevaid veaolukordi, näiteks võrguprobleeme või vigaseid päringuid, ja tagastada sobivad HTTP veakoodid.
*/

/* 5. Dokumentatsioon ja pakettide kasutamine
Jälgi Go keele stiilijuhiseid ja hea koodi tava. Dokumenteeri oma kood selgelt.
Pidage meeles ülesande nõuet kasutada ainult Go standardpakette.
*/

//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////

/* Asünkroonse töötluse rakendamine Go-s kasutab sageli gorutiine ja kanaleid, mis võimaldavad mitme ülesande samaaegset töötlemist ilma,
et blokeeriksid teineteise tööd. See on eriti kasulik veebirakendustes, kus pead käitlema mitmeid võrgupäringuid, failioperatsioone või muid I/O-tegevusi,
mis võivad võtta märkimisväärse hulga aega. Gorutiinide ja kanalite kasutamine aitab parandada rakenduse vastuskiirust ja tõhusust.
*/

// Gorutiinide Kasutamine
// Gorutiin on kergekaaluline niit, mida Go keele käitusaeg (runtime) haldab. Gorutiinide käivitamine on lihtne ja efektiivne viis mitme ülesande samaaegseks töötlemiseks.

// Gorutiinid on funktsioonid või meetodid, mis jooksevad paralleelselt teiste gorutiinidega samas programmiprotsessis. Gorutiini käivitamiseks kasuta
// go võtmesõna enne funktsiooni või meetodi kutset.

// Näide gorutiinide kasutamisest:

// package main

// import (
// 	"fmt"
// 	"time"
// )

// func doSomething(s string) {
// 	for i := 0; i < 5; i++ {
// 		fmt.Println(s, i)
// 		time.Sleep(time.Millisecond * 100) // Oota 100 millisekundit
// 	}
// }

// func main() {
// 	// Käivita doSomething funktsioon gorutiinina
// 	go doSomething("asünkroonselt")

// 	// Samal ajal jätkata peamises gorutiinis teise funktsiooni käitamist
// 	doSomething("sünkroonselt")

// 	// Oota enne programmi lõpetamist, et näha asünkroonse tegevuse tulemusi
// 	time.Sleep(time.Second)
// }

// package main

// import (
// 	"fmt"
// 	"time"
// )

// func say(s string) {
// 	for i := 0; i < 5; i++ {
// 		time.Sleep(100 * time.Millisecond)
// 		fmt.Println(s)
// 	}
// }

// func main() {
// 	go say("world")
// 	say("hello")
// }

/* See programm trükib "hello" ja "world" paralleelselt, vaheldumisi, kuna say("world") käivitatakse gorutiinina.
 */

/*
Kanalite Kasutamine
Kanalid on Go-s viis gorutiinide vahel andmete edastamiseks. Kanalid tagavad, et andmed on turvaliselt edastatud ilma andmete rikkumiseta,
isegi kui mitu gorutiini üritavad samal ajal kanalisse kirjutada või sellest lugeda.

Kanalid on tüübitud vahendid, mille kaudu saab gorutiinide vahel ohutult andmeid edastada. Kanaleid kasutatakse sageli gorutiinide sünkroniseerimiseks ja andmevahetuseks.

	Näide kanalite kasutamisest:
*/
// package main

// import "fmt"

// func produce(c chan<- int) {
// 	for i := 0; i < 50; i++ {
// 		c <- i // Saada väärtus kanalisse
// 	}
// 	close(c) // Sulge kanal pärast kasutamist
// }

// func main() {
// 	c := make(chan int) // Loo uus kanal

// 	go produce(c) // Käivita produce funktsioon gorutiinina

// 	// Loe väärtused kanalist
// 	for v := range c {
// 		fmt.Println("Received:", v)
// 	}
// }

// Näiteks, kui soovid saada andmeid asünkroonselt töötavalt gorutiinilt:
// See programm käivitab funktsiooni compute gorutiinina, mis arvutab arvu ruudu ja saadab tulemuse tagasi põhiprogrammile kasutades kanalit.

// package main

// import "fmt"

// func compute(value int, result chan int) {
// 	// Teostab mingit arvutust
// 	result <- value * value // Saadab arvutuse tulemuse kanalisse
// }

// func main() {
// 	result := make(chan int) // Loob uue kanali integer tüüpi andmete jaoks
// 	go compute(2, result)    // Käivitab gorutiini, mis saadab tulemuse kanalisse
// 	fmt.Println(<-result)    // Loeb tulemuse kanalist ja trükib selle
// }

/*
	Asünkroonse töötluse kasutamine API päringutes

Kui sinu Go veebirakendus teeb päringuid välisele API-le (nagu sinu Node.js Cars API), võid kasutada gorutiine ja kanaleid, et teha need päringud asünkroonselt.
See võimaldab su serveril jätkata teiste päringute teenindamist, samal ajal kui ootab vastust väliselt API-lt, parandades seeläbi rakenduse üldist jõudlust ja
reageerimiskiirust.
*/

// package main

// import "fmt"

// func fetchCarData(url string, data chan<- CarData) {
// 	var car CarData
// 	// Eeldame, et siin tehakse HTTP päring välisele API-le ja parsitakse vastus `car` objekti
// 	data <- car // Saadab saadud andmed tagasi põhiprogrammile kanali kaudu
// }

// func main() {
// 	carData := make(chan CarData)
// 	go fetchCarData("http://example.com/api/car/1", carData)
// 	// Jätkab teiste töödega, kuni carData on saadaval
// 	fmt.Println(<-carData) // Ootab andmeid kanalist
// }
